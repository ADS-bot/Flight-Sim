/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 scene.glb
*/

import React, { useEffect, useMemo, useRef } from "react";
import { MeshReflectorMaterial, useGLTF, Instances, Instance } from "@react-three/drei";
import { Box3, Color, MeshStandardMaterial, Vector3, Matrix4, Object3D } from "three";

// Export grid configuration for other components
export const GRID_SIZE = 3;
export const SKIP_CORNERS = true;

const dummy = new Object3D(); // Reusable object for matrix calculation

export function Landscape(props) {
  const { nodes, materials } = useGLTF("assets/models/scene.glb");

  // Create materials
  const [lightsMaterial, waterMaterial] = useMemo(() => {
    return [
      new MeshStandardMaterial({
        envMapIntensity: 0,
        color: new Color("#ea6619"),
        roughness: 0,
        metalness: 0,
        emissive: new Color("#f6390f").multiplyScalar(1),
      }),
      <MeshReflectorMaterial
        transparent={true}
        opacity={0.6}
        color={"#23281b"}
        roughness={0}
        blur={[10, 10]}
        mixBlur={1}
        mixStrength={15} // Reduced mixStrength for performance
        mixContrast={1.2}
        resolution={128} // Kept reduced resolution
        mirror={0}
        depthScale={0}
        minDepthThreshold={0}
        maxDepthThreshold={0.1}
        depthToBlurRatioBias={0.0025}
        debug={0}
        reflectorOffset={0.0}
      />,
    ];
  }, []);

  // Calculate the bounding box for precise tiling
  const size = useMemo(() => {
    const bbox = new Box3();
    const updateBBoxWithMesh = (geometry) => {
      if (geometry) {
        geometry.computeBoundingBox();
        bbox.union(geometry.boundingBox);
      }
    };
    if (nodes.landscape_gltf?.geometry) updateBBoxWithMesh(nodes.landscape_gltf.geometry);
    if (nodes.landscape_borders?.geometry) updateBBoxWithMesh(nodes.landscape_borders.geometry);
    if (nodes.trees_light?.geometry) updateBBoxWithMesh(nodes.trees_light.geometry);
    if (nodes.lights?.geometry) updateBBoxWithMesh(nodes.lights.geometry);
    const dimensions = new Vector3();
    bbox.getSize(dimensions);
    return dimensions;
  }, [nodes]);

  // Store tile positions for instancing
  const tileData = useMemo(() => {
    if (!size || size.x === 0) return []; // Ensure size is calculated
    const data = [];
    const halfGrid = Math.floor(GRID_SIZE / 2);
    for (let x = 0; x < GRID_SIZE; x++) {
      for (let z = 0; z < GRID_SIZE; z++) {
        if (SKIP_CORNERS && (x === 0 && z === 0 || x === (GRID_SIZE - 1) && z === (GRID_SIZE - 1) || 
            x === 0 && z === (GRID_SIZE - 1) || x === (GRID_SIZE - 1) && z === 0)) {
          continue;
        }
        const posX = (x - halfGrid) * size.x;
        const posZ = (z - halfGrid) * size.z;
        data.push({ x: posX, z: posZ });
      }
    }
    return data;
  }, [size]);

  // Export the calculated size for other components to use
  useEffect(() => {
    if (size && size.x !== 0) {
      window.LANDSCAPE_SIZE = size;
    }
  }, [size]);

  useEffect(() => {
    // Adjust original material properties
    materials["Material.009"].envMapIntensity = 0.75;
    materials["Material.008"].color = new Color("#2f2f13");
    materials["Material.008"].envMapIntensity = 0.3;
    materials["Material.008"].roughness = 1;
    materials["Material.008"].metalness = 0;
  }, [materials]);

  // Memoize water plane positions and scales
  const waterPlanes = useMemo(() => [
    { position: [-2.536, 1.272, 0.79], scale: [1.285, 1.285, 1] },
    { position: [1.729, 0.943, 2.709], scale: [3, 3, 1] },
    { position: [0.415, 1.588, -2.275], scale: [3.105, 2.405, 1] },
  ], []);

  return (
    <group {...props} dispose={null}>
      {/* Instanced Meshes for Landscape Components */}
      <Instances geometry={nodes.landscape_gltf.geometry} material={materials["Material.009"]} castShadow receiveShadow>
        {tileData.map((data, i) => 
          <Instance key={`landscape-${i}`} position={[data.x, 0, data.z]} />
        )}
      </Instances>
      
      <Instances geometry={nodes.landscape_borders.geometry} material={materials["Material.010"]}>
        {tileData.map((data, i) => 
          <Instance key={`border-${i}`} position={[data.x, 0, data.z]} />
        )}
      </Instances>
      
      <Instances geometry={nodes.trees_light.geometry} material={materials["Material.008"]} castShadow>
        {tileData.map((data, i) => 
          <Instance key={`trees-${i}`} position={[data.x, 0, data.z]} />
        )}
      </Instances>
      
      <Instances geometry={nodes.lights.geometry} material={lightsMaterial}>
        {tileData.map((data, i) => 
          <Instance key={`lights-${i}`} position={[data.x, 0, data.z]} />
        )}
      </Instances>

      {/* Water planes - rendered per instance group */}
      {tileData.map((data, i) => (
        <group key={`watergroup-${i}`} position={[data.x, 0, data.z]}>
          {waterPlanes.map((plane, planeIdx) => (
            <mesh
              key={`water-${i}-${planeIdx}`}
              position={plane.position}
              rotation={[-Math.PI * 0.5, 0, 0]}
              scale={plane.scale}
            >
              <planeGeometry args={[1, 1]} />
              {waterMaterial} {/* Note: This creates multiple reflectors, which can still be costly */}
            </mesh>
          ))}
        </group>
      ))}
    </group>
  );
}

useGLTF.preload("assets/models/scene.glb");
