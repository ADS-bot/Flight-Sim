/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 scene.glb
*/

import React, { useEffect, useMemo, useRef } from "react";
import { MeshReflectorMaterial, useGLTF, Instances, Instance } from "@react-three/drei";
import { Box3, Color, MeshStandardMaterial, Vector3, Object3D } from "three";

// Export grid configuration for other components
export const GRID_SIZE = 3;
export const SKIP_CORNERS = true;

const dummy = new Object3D(); // Reusable object for matrix calculation

export function Landscape(props) {
  const { nodes, materials } = useGLTF("assets/models/scene.glb");

  // Create materials
  const [lightsMaterial, waterMaterial] = useMemo(() => {
    return [
      new MeshStandardMaterial({
        envMapIntensity: 0,
        color: new Color("#ea6619"),
        roughness: 0,
        metalness: 0,
        emissive: new Color("#f6390f").multiplyScalar(1),
      }),
      <MeshReflectorMaterial
        transparent={true}
        opacity={0.6}
        color={"#23281b"}
        roughness={0}
        blur={[20, 20]}
        mixBlur={1}
        mixStrength={10}
        mixContrast={1.2}
        resolution={64}
        mirror={0}
        depthScale={0}
        minDepthThreshold={0}
        maxDepthThreshold={0.1}
        depthToBlurRatioBias={0.0025}
        debug={0}
        reflectorOffset={0.0}
      />,
    ];
  }, []);

  // Calculate the bounding box for precise tiling
  const size = useMemo(() => {
    const bbox = new Box3();
    const updateBBoxWithMesh = (geometry) => {
      if (geometry) {
        geometry.computeBoundingBox();
        bbox.union(geometry.boundingBox);
      }
    };
    if (nodes.landscape_gltf?.geometry) updateBBoxWithMesh(nodes.landscape_gltf.geometry);
    if (nodes.landscape_borders?.geometry) updateBBoxWithMesh(nodes.landscape_borders.geometry);
    if (nodes.trees_light?.geometry) updateBBoxWithMesh(nodes.trees_light.geometry);
    if (nodes.lights?.geometry) updateBBoxWithMesh(nodes.lights.geometry);
    const dimensions = new Vector3();
    bbox.getSize(dimensions);
    // Prevent division by zero or issues if model loads weirdly
    if (dimensions.x === 0) dimensions.x = 10; 
    if (dimensions.z === 0) dimensions.z = 10;
    return dimensions;
  }, [nodes]);

  // Store tile positions for instancing
  const tileData = useMemo(() => {
    if (!size || size.x === 0) return []; // Ensure size is calculated
    const data = [];
    const halfGrid = Math.floor(GRID_SIZE / 2);
    for (let x = 0; x < GRID_SIZE; x++) {
      for (let z = 0; z < GRID_SIZE; z++) {
        if (SKIP_CORNERS && (x === 0 && z === 0 || x === (GRID_SIZE - 1) && z === (GRID_SIZE - 1) || 
            x === 0 && z === (GRID_SIZE - 1) || x === (GRID_SIZE - 1) && z === 0)) {
          continue;
        }
        const posX = (x - halfGrid) * size.x;
        const posZ = (z - halfGrid) * size.z;
        data.push({ x: posX, z: posZ });
      }
    }
    return data;
  }, [size]);

  // Calculate total grid size for the single water plane
  const totalGridSize = useMemo(() => {
    if (!size || size.x === 0) return { width: 10, height: 10 };
    // Since grid is centered, total size is GRID_SIZE * tileSize
    return { width: GRID_SIZE * size.x, height: GRID_SIZE * size.z }; 
  }, [size]);

  // Export the calculated size for other components to use
  useEffect(() => {
    if (size && size.x !== 0) {
      window.LANDSCAPE_SIZE = size;
    }
  }, [size]);

  useEffect(() => {
    // Adjust original material properties
    materials["Material.009"].envMapIntensity = 0.75;
    materials["Material.008"].color = new Color("#2f2f13");
    materials["Material.008"].envMapIntensity = 0.3;
    materials["Material.008"].roughness = 1;
    materials["Material.008"].metalness = 0;
  }, [materials]);

  return (
    <group {...props} dispose={null}>
      {/* Instanced Meshes for Landscape Components */}
      <Instances geometry={nodes.landscape_gltf.geometry} material={materials["Material.009"]} castShadow receiveShadow>
        {tileData.map((data, i) => 
          <Instance key={`landscape-${i}`} position={[data.x, 0, data.z]} name="landscape_terrain" />
        )}
      </Instances>
      
      <Instances geometry={nodes.landscape_borders.geometry} material={materials["Material.010"]}>
        {tileData.map((data, i) => 
          <Instance key={`border-${i}`} position={[data.x, 0, data.z]} name="landscape_border" />
        )}
      </Instances>
      
      <Instances geometry={nodes.trees_light.geometry} material={materials["Material.008"]} castShadow>
        {tileData.map((data, i) => 
          <Instance key={`trees-${i}`} position={[data.x, 0, data.z]} name="landscape_trees" />
        )}
      </Instances>
      
      <Instances geometry={nodes.lights.geometry} material={lightsMaterial}>
        {tileData.map((data, i) => 
          <Instance key={`lights-${i}`} position={[data.x, 0, data.z]} name="landscape_lights" />
        )}
      </Instances>

      {/* Single Water plane for the entire grid - MORE EFFICIENT */}
      {size && size.x !== 0 && (
        <mesh 
          position={[0, 1.0, 0]} // Position at average water level 
          rotation={[-Math.PI * 0.5, 0, 0]}
          name="landscape_water"
        >
          <planeGeometry args={[totalGridSize.width, totalGridSize.height]} />
          {waterMaterial}
        </mesh>
      )}

    </group>
  );
}

useGLTF.preload("assets/models/scene.glb");
