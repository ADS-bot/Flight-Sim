/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.7 public/assets/models/airplane.glb
*/

import React, { useRef, useEffect, useState, useMemo } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber';
import { Matrix4, Quaternion, Raycaster, Vector3 } from 'three';
import { updatePlaneAxis, getPlaneSpeed, turbo } from './controls';
import { useFlightData } from './contexts/FlightDataContext';

const x = new Vector3(1, 0, 0);
const y = new Vector3(0, 1, 0);
const z = new Vector3(0, 0, 1);
export const planePosition = new Vector3(0, 3, 15); // Increased Z from 7 to 15 for a more distant starting position

// Keep these separate, they are for the plane's orientation
const rotMatrix = new Matrix4();
const delayedRotMatrix = new Matrix4();
const delayedQuaternion = new Quaternion();

// Change this to use your preferred model: "airplane.glb", "airplane1.glb", or "scene.glb"
const MODEL_PATH = 'assets/models/airplane.glb';

// Adjust the scale factor as needed
const MODEL_SCALE = 0.0004; // Increased from 0.01 to zoom out 0.003-0.0003

// Minimum height above terrain
const MIN_TERRAIN_CLEARANCE = 0.1;

// For collision detection
const raycaster = new Raycaster();
const downDirection = new Vector3(0, -1, 0);

// Accept isUserInteracting prop
export function Airplane({ orbitControlsRef, isUserInteracting, ...props }) {
  const groupRef = useRef();
  const helixMeshRef = useRef();
  const [modelReady, setModelReady] = useState(false);
  const { scene } = useThree();
  const { updateFlightData } = useFlightData();
  
  const { nodes, materials } = useGLTF(MODEL_PATH);
  
  useEffect(() => {
    if (nodes && Object.keys(nodes).length > 0) {
      console.log("Model loaded successfully:", Object.keys(nodes));
      setModelReady(true);
    } else {
      console.error("Failed to load model or model has no nodes");
    }
  }, [nodes]);

  // Memoize vectors to avoid recreating them every frame
  const cameraPosition = useMemo(() => new Vector3(), []);
  const cameraTarget = useMemo(() => new Vector3(), []);

  // Initialize cameraPosition with the actual camera's starting position
  useEffect(() => {
    if (orbitControlsRef.current?.object) {
      cameraPosition.copy(orbitControlsRef.current.object.position);
      cameraTarget.copy(orbitControlsRef.current.target);
    }
  }, [orbitControlsRef]); // Run only once when controls are available

  useFrame(({ camera }, delta) => {
    if (!groupRef.current || !orbitControlsRef?.current) return;
    
    const oldPosition = planePosition.clone();
    
    updatePlaneAxis(x, y, z, planePosition, camera);
    
    // Collision detection with terrain
    // We'll raycast downward from the airplane
    raycaster.set(planePosition, downDirection);
    
    // Get all objects in the scene that could collide
    // We're interested in landscape meshes
    const intersects = raycaster.intersectObjects(scene.children, true);
    
    // Find the closest valid intersection
    let terrainHeight = -Infinity;
    for (let i = 0; i < intersects.length; i++) {
      const intersect = intersects[i];
      
      // Skip if it's the airplane itself or non-landscape objects
      // We check if the object name includes these common landscape-related terms
      const objName = intersect.object.name.toLowerCase();
      if (objName.includes('landscape') || objName.includes('terrain') || objName.includes('ground')) {
        terrainHeight = Math.max(terrainHeight, intersect.point.y);
      }
    }
    
    // If we found terrain below us
    if (terrainHeight !== -Infinity) {
      // Ensure minimum clearance
      const minHeight = terrainHeight + MIN_TERRAIN_CLEARANCE;
      
      // If we're too low, restore the old position and adjust height
      if (planePosition.y < minHeight) {
        // Option 1: Just bounce up to min height (simple but abrupt)
        planePosition.y = minHeight;
        
        // Option 2: Restore most of old position & momentum but adjust height
        // This provides smoother response, as if the plane is gliding along the terrain
        if (oldPosition.y >= minHeight) {
          // If we were above terrain before, slide along the surface
          planePosition.copy(oldPosition);
          // Move forward at a fraction of the original speed to simulate slowing down
          const forwardMove = z.clone().multiplyScalar(-0.01);
          planePosition.add(forwardMove);
          // Set to minimum height
          planePosition.y = minHeight;
        }
      }
    }

    // Calculate the effective speed
    const easeOutQuad = (t) => t * (2 - t); 
    const turboSpeedComponent = easeOutQuad(turbo) * 0.02;
    const baseSpeed = getPlaneSpeed(); // Get current base speed
    // Adjust scaling factor to approximate knots (e.g., map max raw speed ~0.12 to ~250 knots)
    const currentEffectiveSpeed = (baseSpeed + turboSpeedComponent) * 2000; 
    const currentHeight = planePosition.y;

    // Log values every frame for debugging
    // console.log(`BaseSpeed: ${baseSpeed.toFixed(4)}, Turbo: ${turbo.toFixed(4)}, EffectiveSpeed: ${currentEffectiveSpeed.toFixed(0)}, Height: ${currentHeight.toFixed(1)}`);

    // Update context unconditionally
    updateFlightData({ 
      speed: currentEffectiveSpeed,
      height: currentHeight
    });

    // Update plane's matrix
    rotMatrix.makeBasis(x, y, z);
    const matrix = new Matrix4()
      .multiply(new Matrix4().makeTranslation(planePosition.x, planePosition.y, planePosition.z))
      .multiply(rotMatrix);
    groupRef.current.matrixAutoUpdate = false;
    groupRef.current.matrix.copy(matrix);
    groupRef.current.matrixWorldNeedsUpdate = true;

    // Calculate the smooth delayed rotation for the camera
    const quaternionA = new Quaternion().copy(delayedQuaternion);
    const quaternionB = new Quaternion();
    quaternionB.setFromRotationMatrix(rotMatrix);
    const interpolationFactor = 0.175;
    const interpolatedQuaternion = new Quaternion().copy(quaternionA);
    interpolatedQuaternion.slerp(quaternionB, interpolationFactor);
    delayedQuaternion.copy(interpolatedQuaternion);
    delayedRotMatrix.identity().makeRotationFromQuaternion(delayedQuaternion);

    // Calculate the desired camera position based on the plane's delayed rotation
    const idealOffset = new Vector3(0, 0.5, 2.0); // Base offset behind the plane
    idealOffset.applyMatrix4(delayedRotMatrix);
    idealOffset.add(planePosition);

    const idealLookAt = planePosition;

    // Make interpolation smoother
    const lerpFactor = 0.05; // Smaller value = smoother/slower interpolation

    if (!isUserInteracting) {
      // Smoothly interpolate camera position and target towards the ideal ones
      cameraPosition.lerp(idealOffset, lerpFactor);
      cameraTarget.lerp(idealLookAt, lerpFactor);

      // Apply the interpolated position and lookAt to the actual camera
      camera.position.copy(cameraPosition);
      camera.lookAt(cameraTarget);

      // Sync OrbitControls target and update it
      orbitControlsRef.current.target.copy(cameraTarget);
      // orbitControlsRef.current.update(); // update() is likely called by the R3F loop automatically
    } else {
      // While user is interacting, update our internal state to match the controls
      cameraPosition.copy(orbitControlsRef.current.object.position);
      cameraTarget.copy(orbitControlsRef.current.target);
      
      // Keep the target focused on the plane, allowing OrbitControls to handle position/zoom
      orbitControlsRef.current.target.copy(idealLookAt);
      // orbitControlsRef.current.update(); // update() is likely called by the R3F loop automatically
    }

    // Rotate helix
    if (helixMeshRef.current) {
      helixMeshRef.current.rotation.z -= 1.0;
    }
  });

  const renderModel = () => {
    if (nodes.supports && nodes.chassis && nodes.helix) {
      return (
        <group {...props} dispose={null} scale={MODEL_SCALE} rotation-y={Math.PI}>
          <mesh geometry={nodes.supports.geometry} material={materials['Material.004']} />
          <mesh geometry={nodes.chassis.geometry} material={materials['Material.005']} />
          <mesh geometry={nodes.helix.geometry} material={materials['Material.005']} ref={helixMeshRef} />
        </group>
      );
    } else {
      return (
        <group {...props} dispose={null} scale={MODEL_SCALE} rotation-y={Math.PI}>
          {Object.keys(nodes).map((nodeName) => {
            const node = nodes[nodeName];
            if (node.geometry) {
              if (nodeName.toLowerCase().includes('helix') || 
                  nodeName.toLowerCase().includes('propeller')) {
                return (
                  <mesh 
                    key={nodeName} 
                    geometry={node.geometry} 
                    material={node.material} 
                    ref={helixMeshRef}
                  />
                );
              }
              return (
                <mesh 
                  key={nodeName} 
                  geometry={node.geometry} 
                  material={node.material}
                />
              );
            }
            return null;
          })}
        </group>
      );
    }
  };

  return (
    <>
      <group ref={groupRef}>
        {modelReady && renderModel()}
      </group>
    </>
  );
}

useGLTF.preload(MODEL_PATH);
