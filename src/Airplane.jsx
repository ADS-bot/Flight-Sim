/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.7 public/assets/models/airplane.glb
*/

import React, { useRef, useEffect, useState, useMemo } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber';
import { Matrix4, Quaternion, Vector3 } from 'three';
import { updatePlaneAxis } from './controls';

const x = new Vector3(1, 0, 0);
const y = new Vector3(0, 1, 0);
const z = new Vector3(0, 0, 1);
export const planePosition = new Vector3(0, 3, 15);

// Keep these separate, they are for the plane's orientation
const rotMatrix = new Matrix4();
const delayedRotMatrix = new Matrix4();
const delayedQuaternion = new Quaternion();

// Change this to use your preferred model: "airplane.glb", "airplane1.glb", or "scene.glb"
const MODEL_PATH = 'assets/models/airplane.glb';

// Adjust the scale factor as needed
const MODEL_SCALE = 0.0004; // Increased from 0.01 to zoom out 0.003-0.0003

// Accept isUserInteracting prop
export function Airplane({ orbitControlsRef, isUserInteracting, ...props }) {
  const groupRef = useRef();
  const helixMeshRef = useRef();
  const [modelReady, setModelReady] = useState(false);
  
  const { nodes, materials } = useGLTF(MODEL_PATH);
  
  useEffect(() => {
    if (nodes && Object.keys(nodes).length > 0) {
      console.log("Model loaded successfully:", Object.keys(nodes));
      setModelReady(true);
    } else {
      console.error("Failed to load model or model has no nodes");
    }
  }, [nodes]);

  // Memoize vectors to avoid recreating them every frame
  const cameraPosition = useMemo(() => new Vector3(), []);
  const cameraTarget = useMemo(() => new Vector3(), []);

  // Initialize cameraPosition with the actual camera's starting position
  useEffect(() => {
    if (orbitControlsRef.current?.object) {
      cameraPosition.copy(orbitControlsRef.current.object.position);
      cameraTarget.copy(orbitControlsRef.current.target);
    }
  }, [orbitControlsRef]); // Run only once when controls are available

  useFrame(({ camera }) => {
    if (!groupRef.current || !orbitControlsRef?.current) return;
    
    updatePlaneAxis(x, y, z, planePosition, camera);

    // Update plane's matrix
    rotMatrix.makeBasis(x, y, z);
    const matrix = new Matrix4()
      .multiply(new Matrix4().makeTranslation(planePosition.x, planePosition.y, planePosition.z))
      .multiply(rotMatrix);
    groupRef.current.matrixAutoUpdate = false;
    groupRef.current.matrix.copy(matrix);
    groupRef.current.matrixWorldNeedsUpdate = true;

    // Calculate the smooth delayed rotation for the camera
    const quaternionA = new Quaternion().copy(delayedQuaternion);
    const quaternionB = new Quaternion();
    quaternionB.setFromRotationMatrix(rotMatrix);
    const interpolationFactor = 0.175;
    const interpolatedQuaternion = new Quaternion().copy(quaternionA);
    interpolatedQuaternion.slerp(quaternionB, interpolationFactor);
    delayedQuaternion.copy(interpolatedQuaternion);
    delayedRotMatrix.identity().makeRotationFromQuaternion(delayedQuaternion);

    // Calculate the desired camera position based on the plane's delayed rotation
    const idealOffset = new Vector3(0, 0.5, 2.0); // Base offset behind the plane
    idealOffset.applyMatrix4(delayedRotMatrix);
    idealOffset.add(planePosition);

    const idealLookAt = planePosition;

    // Make interpolation smoother
    const lerpFactor = 0.05; // Smaller value = smoother/slower interpolation

    if (!isUserInteracting) {
      // Smoothly interpolate camera position and target towards the ideal ones
      cameraPosition.lerp(idealOffset, lerpFactor);
      cameraTarget.lerp(idealLookAt, lerpFactor);

      // Apply the interpolated position and lookAt to the actual camera
      camera.position.copy(cameraPosition);
      camera.lookAt(cameraTarget);

      // Sync OrbitControls target and update it
      orbitControlsRef.current.target.copy(cameraTarget);
      // orbitControlsRef.current.update(); // update() is likely called by the R3F loop automatically
    } else {
      // While user is interacting, update our internal state to match the controls
      cameraPosition.copy(orbitControlsRef.current.object.position);
      cameraTarget.copy(orbitControlsRef.current.target);
      
      // Keep the target focused on the plane, allowing OrbitControls to handle position/zoom
      orbitControlsRef.current.target.copy(idealLookAt);
      // orbitControlsRef.current.update(); // update() is likely called by the R3F loop automatically
    }

    // Rotate helix
    if (helixMeshRef.current) {
      helixMeshRef.current.rotation.z -= 1.0;
    }
  });

  const renderModel = () => {
    if (nodes.supports && nodes.chassis && nodes.helix) {
      return (
        <group {...props} dispose={null} scale={MODEL_SCALE} rotation-y={Math.PI}>
          <mesh geometry={nodes.supports.geometry} material={materials['Material.004']} />
          <mesh geometry={nodes.chassis.geometry} material={materials['Material.005']} />
          <mesh geometry={nodes.helix.geometry} material={materials['Material.005']} ref={helixMeshRef} />
        </group>
      );
    } else {
      return (
        <group {...props} dispose={null} scale={MODEL_SCALE} rotation-y={Math.PI}>
          {Object.keys(nodes).map((nodeName) => {
            const node = nodes[nodeName];
            if (node.geometry) {
              if (nodeName.toLowerCase().includes('helix') || 
                  nodeName.toLowerCase().includes('propeller')) {
                return (
                  <mesh 
                    key={nodeName} 
                    geometry={node.geometry} 
                    material={node.material} 
                    ref={helixMeshRef}
                  />
                );
              }
              return (
                <mesh 
                  key={nodeName} 
                  geometry={node.geometry} 
                  material={node.material}
                />
              );
            }
            return null;
          })}
        </group>
      );
    }
  };

  return (
    <>
      <group ref={groupRef}>
        {modelReady && renderModel()}
      </group>
    </>
  );
}

useGLTF.preload(MODEL_PATH);
