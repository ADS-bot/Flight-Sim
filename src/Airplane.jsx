/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.7 public/assets/models/airplane.glb
*/

import React, { useRef, useEffect, useState, useMemo } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber';
import { Matrix4, Quaternion, Raycaster, Vector3 } from 'three';
import { updatePlaneAxis, getPlaneSpeed, turbo } from './controls';
import { useFlightData } from './contexts/FlightDataContext';
import { useGameState } from './contexts/GameStateContext';

const x = new Vector3(1, 0, 0);
const y = new Vector3(0, 1, 0);
const z = new Vector3(0, 0, 1);
// Starting position constants
const STARTING_X = 0;
const STARTING_Y = 3;
const STARTING_Z = 15;
export const planePosition = new Vector3(STARTING_X, STARTING_Y, STARTING_Z); // Increased Z from 7 to 15 for a more distant starting position

// Keep these separate, they are for the plane's orientation
const rotMatrix = new Matrix4();
const delayedRotMatrix = new Matrix4();
const delayedQuaternion = new Quaternion();

// Change this to use your preferred model: "airplane.glb", "airplane1.glb", or "scene.glb"
const MODEL_PATH = 'assets/models/airplane.glb';

// Adjust the scale factor as needed
const MODEL_SCALE = 0.0004; // Increased from 0.01 to zoom out 0.003-0.0003

// Minimum height above terrain
const MIN_TERRAIN_CLEARANCE = 0.05;
const COLLISION_THRESHOLD = 0.05; // Threshold for actual collision

// For collision detection
const raycaster = new Raycaster();
const downDirection = new Vector3(0, -1, 0);

// Function to reset plane vectors
export function resetPlaneVectors() {
  x.set(1, 0, 0);
  y.set(0, 1, 0);
  z.set(0, 0, 1);
  planePosition.set(STARTING_X, STARTING_Y, STARTING_Z);
  delayedQuaternion.set(0, 0, 0, 1);
  rotMatrix.identity();
  delayedRotMatrix.identity();
}

// Accept isUserInteracting prop
export function Airplane({ orbitControlsRef, isUserInteracting, ...props }) {
  const groupRef = useRef();
  const helixMeshRef = useRef();
  const [modelReady, setModelReady] = useState(false);
  const { scene } = useThree();
  const { updateFlightData } = useFlightData();
  const { gameState, setCollision, resetGame } = useGameState();
 
  const { nodes, materials } = useGLTF(MODEL_PATH);
  
  // Store references to potentially collidable objects
  const collidableObjectsRef = useRef([]);
  const landscapeObjectsRef = useRef([]); // Specific ref for landscape objects
  
  // Add keyboard event listener for "r" key to reset position
  useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key.toLowerCase() === 'r') {
        console.log("'r' key pressed - resetting airplane position");
        if (gameState.isGameOver) {
          // If game over, use the resetGame function to properly restart
          resetGame();
        } else {
          // If not game over, just reset position
          resetPlaneVectors();
        }
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    
    // Cleanup event listener on component unmount
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [gameState.isGameOver, resetGame]);
  
  useEffect(() => {
    if (gameState.wasReset) {
      console.log("Game reset detected, resetting plane vectors");
      resetPlaneVectors();
    }
  }, [gameState.wasReset]);
 
  useEffect(() => {
    if (nodes && Object.keys(nodes).length > 0) {
      console.log("Model loaded successfully:", Object.keys(nodes));
      setModelReady(true);
    } else {
      console.error("Failed to load model or model has no nodes");
    }
  }, [nodes]);

  // Memoize vectors to avoid recreating them every frame
  const cameraPosition = useMemo(() => new Vector3(), []);
  const cameraTarget = useMemo(() => new Vector3(), []);

  // Initialize cameraPosition with the actual camera's starting position
  useEffect(() => {
    if (orbitControlsRef.current?.object) {
      cameraPosition.copy(orbitControlsRef.current.object.position);
      cameraTarget.copy(orbitControlsRef.current.target);
    }
  }, [orbitControlsRef]); // Run only once when controls are available

  useFrame(({ camera }, delta) => {
    if (!groupRef.current || !orbitControlsRef?.current) return;
    
    // Skip updates if game is over
    if (gameState.isGameOver) return;
   
    const oldPosition = planePosition.clone();
   
    updatePlaneAxis(x, y, z, planePosition, camera);
   
    // Collision detection with terrain
    // We'll raycast downward from the airplane
    raycaster.set(planePosition, downDirection);
   
    // Get all objects in the scene that could collide
    // We're interested in landscape meshes
    const intersects = raycaster.intersectObjects(scene.children, true);
   
    // Find the closest valid intersection
    let terrainHeight = -Infinity;
    for (let i = 0; i < intersects.length; i++) {
      const intersect = intersects[i];
     
      // Skip if it's the airplane itself or non-landscape objects
      // We check if the object name includes these common landscape-related terms
      const objName = intersect.object.name.toLowerCase();
      if (objName.includes('landscape') || objName.includes('terrain') || objName.includes('ground')) {
        terrainHeight = Math.max(terrainHeight, intersect.point.y);
        
        // Check if we're too close to the ground (actual collision)
        const distanceToGround = planePosition.y - intersect.point.y;
        if (distanceToGround <= COLLISION_THRESHOLD) {
          console.log("COLLISION with landscape detected!");
          setCollision(planePosition.clone());
          return; // Stop further processing
        }
      }
    }
   
    // If we found terrain below us
    if (terrainHeight !== -Infinity) {
      // Ensure minimum clearance
      const minHeight = terrainHeight + MIN_TERRAIN_CLEARANCE;
     
      // If we're too low, restore the old position and adjust height
      if (planePosition.y < minHeight) {
        // Option 1: Just bounce up to min height (simple but abrupt)
        planePosition.y = minHeight;
       
        // Option 2: Restore most of old position & momentum but adjust height
        // This provides smoother response, as if the plane is gliding along the terrain
        if (oldPosition.y >= minHeight) {
          // If we were above terrain before, slide along the surface
          planePosition.copy(oldPosition);
          // Move forward at a fraction of the original speed to simulate slowing down
          const forwardMove = z.clone().multiplyScalar(-0.01);
          planePosition.add(forwardMove);
          // Set to minimum height
          planePosition.y = minHeight;
        }
      }
    }

    // Additional forward collision check (prevent going through walls)
    const forwardDirection = z.clone().multiplyScalar(-1);
    raycaster.set(planePosition, forwardDirection);
    const forwardIntersects = raycaster.intersectObjects(scene.children, true);
    
    for (let i = 0; i < forwardIntersects.length; i++) {
      const intersect = forwardIntersects[i];
      const objName = intersect.object.name.toLowerCase();
      
      if (objName.includes('landscape') || objName.includes('terrain') || 
          objName.includes('ground') || objName.includes('border')) {
        // If we're about to hit something in front
        if (intersect.distance < 0.3) { // Forward collision threshold
          console.log("FORWARD COLLISION with landscape detected!");
          setCollision(planePosition.clone().add(forwardDirection.multiplyScalar(intersect.distance)));
          return; // Stop further processing
        }
      }
    }

    // Calculate the effective speed (base speed + turbo contribution)
    // Use easeOutQuad for turbo like in controls.js
    const easeOutQuad = (t) => t * (2 - t);
    const turboSpeedComponent = easeOutQuad(turbo) * 0.02; // Match turbo calculation in controls
    const baseSpeed = getPlaneSpeed(); // Get current base speed
    const currentEffectiveSpeed = (baseSpeed + turboSpeedComponent) * 2000; // Use getPlaneSpeed + turbo, scale for readability
    const currentHeight = planePosition.y;

    // Update context unconditionally
    updateFlightData({
      speed: currentEffectiveSpeed,
      height: currentHeight
    });

    // Update plane's matrix
    rotMatrix.makeBasis(x, y, z);
    const matrix = new Matrix4()
      .multiply(new Matrix4().makeTranslation(planePosition.x, planePosition.y, planePosition.z))
      .multiply(rotMatrix);
    groupRef.current.matrixAutoUpdate = false;
    groupRef.current.matrix.copy(matrix);
    groupRef.current.matrixWorldNeedsUpdate = true;

    // Calculate the smooth delayed rotation for the camera
    const quaternionA = new Quaternion().copy(delayedQuaternion);
    const quaternionB = new Quaternion();
    quaternionB.setFromRotationMatrix(rotMatrix);
    const interpolationFactor = 0.175;
    const interpolatedQuaternion = new Quaternion().copy(quaternionA);
    interpolatedQuaternion.slerp(quaternionB, interpolationFactor);
    delayedQuaternion.copy(interpolatedQuaternion);
    delayedRotMatrix.identity().makeRotationFromQuaternion(delayedQuaternion);

    // Calculate the desired camera position based on the plane's delayed rotation
    const idealOffset = new Vector3(0, 0.5, 2.0); // Base offset behind the plane
    idealOffset.applyMatrix4(delayedRotMatrix);
    idealOffset.add(planePosition);

    const idealLookAt = planePosition;

    // Make interpolation smoother
    const lerpFactor = 0.05; // Smaller value = smoother/slower interpolation

    if (!isUserInteracting) {
      // Smoothly interpolate camera position and target towards the ideal ones
      cameraPosition.lerp(idealOffset, lerpFactor);
      cameraTarget.lerp(idealLookAt, lerpFactor);

      // Apply the interpolated position and lookAt to the actual camera
      camera.position.copy(cameraPosition);
      camera.lookAt(cameraTarget);

      // Sync OrbitControls target and update it
      orbitControlsRef.current.target.copy(cameraTarget);
    } else {
      // While user is interacting, update our internal state to match the controls
      cameraPosition.copy(orbitControlsRef.current.object.position);
      cameraTarget.copy(orbitControlsRef.current.target);
     
      // Keep the target focused on the plane, allowing OrbitControls to handle position/zoom
      orbitControlsRef.current.target.copy(idealLookAt);
    }

    // Rotate helix
    if (helixMeshRef.current) {
      helixMeshRef.current.rotation.z -= 1.0;
    }
  });

  const renderModel = () => {
    if (nodes.supports && nodes.chassis && nodes.helix) {
      return (
        <group {...props} dispose={null} scale={MODEL_SCALE} rotation-y={Math.PI}>
          <mesh geometry={nodes.supports.geometry} material={materials['Material.004']} />
          <mesh geometry={nodes.chassis.geometry} material={materials['Material.005']} />
          <mesh geometry={nodes.helix.geometry} material={materials['Material.005']} ref={helixMeshRef} />
        </group>
      );
    } else {
      return (
        <group {...props} dispose={null} scale={MODEL_SCALE} rotation-y={Math.PI}>
          {Object.keys(nodes).map((nodeName) => {
            const node = nodes[nodeName];
            if (node.geometry) {
              if (nodeName.toLowerCase().includes('helix') || 
                  nodeName.toLowerCase().includes('propeller')) {
                return (
                  <mesh 
                    key={nodeName} 
                    geometry={node.geometry} 
                    material={node.material} 
                    ref={helixMeshRef}
                  />
                );
              }
              return (
                <mesh 
                  key={nodeName} 
                  geometry={node.geometry} 
                  material={node.material}
                />
              );
            }
            return null;
          })}
        </group>
      );
    }
  };

  return (
    <>
      <group ref={groupRef}>
        {modelReady && renderModel()}
      </group>
    </>
  );
}

useGLTF.preload(MODEL_PATH);
